概论作业4 

1.解释作业、进程、线程的概念，进程和线程概念的提出分别解决了什么问题？

作业：在某些操作系统中，作业（job）是计算机操作者（或是一个叫做作业调度器的程序）交给操作系统的执行单    位。作业是用户在一次算题过程中或一个事务处理中要求计算机系统所做的工作的集合。作业是一个比程序更为广泛的概念，它不仅包含了通常的程序和数据，而且还应配有一份作业说明书。系统通过作业说明书控制文件形式的程序和数据，使之执行和操作，并在系统中建立作业控制块的数据结构。

进程：进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。

线程：线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。

进程概念的提出，解决了多道程序出现后，系统内部出现的动态情况和各道程序的活动规律的描述的问题。

随着计算机技术的发展，进程出现了很多弊端，一是由于进程是资源拥有者，创建、撤消与切换存在较大的时空开销，因此需要引入轻型进程；二是由于对称多处理机（SMP）出现，可以满足多个运行单位，而多个进程并行开销过大。线程的出现主要解决了这些问题。

2.描述哲学家就餐问题及解法，说明同步、互斥、死锁、活锁的概念。

假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗意大利面，每两个哲学家之间有一只餐叉。因为用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐叉。
哲学家从来不交谈，这就很危险，可能产生死锁，每个哲学家都拿着左手的餐叉，永远都在等右边的餐叉（或者相反）。即使没有死锁，也有可能发生资源耗尽。例如，假设规定当哲学家等待另一只餐叉超过五分钟后就放下自己手里的那一只餐叉，并且再等五分钟后进行下一次尝试。这个策略消除了死锁（系统总会进入到下一个状态），但仍然有可能发生“活锁”。如果五位哲学家在完全相同的时刻进入餐厅，并同时拿起左边的餐叉，那么这些哲学家就会等待五分钟，同时放下手中的餐叉，再等五分钟，又同时拿起这些餐叉。

解法：

服务生解法
一个简单的解法是引入一个餐厅服务生，哲学家必须经过他的允许才能拿起餐叉。因为服务生知道哪只餐叉正在使用，所以他能够作出判断避免死锁。
为了演示这种解法，假设哲学家依次标号为A至E。如果A和C在吃东西，则有四只餐叉在使用中。B坐在A和C之间，所以两只餐叉都无法使用，而D和E之间有一只空余的餐叉。假设这时D想要吃东西。如果他拿起了第五只餐叉，就有可能发生死锁。相反，如果他征求服务生同意，服务生会让他等待。这样，我们就能保证下次当两把餐叉空余出来时，一定有一位哲学家可以成功的得到一对餐叉，从而避免了死锁。

资源分级解法
另一个简单的解法是为资源（这里是餐叉）分配一个偏序或者分级的关系，并约定所有资源都按照这种顺序获取，按相反顺序释放，而且保证不会有两个无关资源同时被同一项工作所需要。在哲学家就餐问题中，资源（餐叉）按照某种规则编号为1至5，每一个工作单元（哲学家）总是先拿起左右两边编号较低的餐叉，再拿编号较高的。用完餐叉后，他总是先放下编号较高的餐叉，再放下编号较低的。在这种情况下，当四位哲学家同时拿起他们手边编号较低的餐叉时，只有编号最高的餐叉留在桌上，从而第五位哲学家就不能使用任何一只餐叉了。而且，只有一位哲学家能使用最高编号的餐叉，所以他能使用两只餐叉用餐。当他吃完后，他会先放下编号最高的餐叉，再放下编号较低的餐叉，从而让另一位哲学家拿起后边的这只开始吃东西。
(这个解法不能保证效率)

Chandy/Misra解法
1.对每一对竞争一个资源的哲学家，新拿一个餐叉，给编号较低的哲学家。每只餐叉都是“干净的”或者“脏的”。最初，所有的餐叉都是脏的。
2.当一位哲学家要使用资源（也就是要吃东西）时，他必须从与他竞争的邻居那里得到。对每只他当前没有的餐叉，他都发送一个请求。
3.当拥有餐叉的哲学家收到请求时，如果餐叉是干净的，那么他继续留着，否则就擦干净并交出餐叉。
4.当某个哲学家吃东西后，他的餐叉就变脏了。如果另一个哲学家之前请求过其中的餐叉，那他就擦干净并交出餐叉。

同步：一般指的是在两个或多个数据库、文件、模块、线程之间用来保持数据内容一致性的机制。
线程同步解决的是在一个程序中多个线程之间的关系的协调，对竞争资源的访问的一种处理方式，避免一个线程长期占用一个资源的目的。

互斥：计算机系统中，多个并发执行的线程之间由于竞争某些共享资源也可能存在与此类似的相互制约关系，线程之间这种因共享资源而产生的制约关系称为互斥。

死锁：两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试—失败—尝试—失败的过程。处于活锁的实体是在不断的改变状态，活锁有可能自行解开。

3.了解磁盘、分区、简单卷、跨区卷等磁盘管理中的概念。

磁盘：计算机的外部存储器。将圆形的磁性盘片装在一个方的密封盒子里，这样做的目的是为了防止磁盘表面划伤，导致数据丢失。

分区：像物理上独立的磁盘那样工作的物理磁盘部分。创建分区后，将数据存储在该分区之前必须将其格式化并指派驱动器号。

主分区：是标记为由操作系统使用的一部分物理磁盘。一个磁盘最多可有4个主分区（或者如果有1个扩展分区，则最多有3个主分区）。

扩展分区：是从硬盘的可用空间上创建的分区，而且可以将其再划分为逻辑驱动器；创建扩展分区不需要有主分区。

简单卷：简单卷必须建立在动态磁盘上，物理磁盘的一部分，但它工作时就好像是物理上的一个独立单元。简单卷是相当于 Windows NT 4.0 及更早版本中的主分区的动态存储。当您只有一个动态磁盘时，简单卷是您可以创建的唯一卷。

跨区卷：跨区卷必须建立在动态磁盘上，是一种和简单卷结构相似的动态卷。跨区卷将来自多个磁盘的未分配空间合并到一个逻辑卷中，这样您可以更有效地使用多个磁盘系统上的所有空间和所有驱动器号。如果需要创建卷，但又没有足够的未分配空间分配给单个磁盘上的卷，则可通过将来自多个磁盘的未分配空间的扇区合并到一个跨区卷来创建足够大的卷。用于创建跨区卷的未分配空间区域的大小可以不同。跨区卷是这样组织的，先将一个磁盘上为卷分配的空间充满，然后从下一个磁盘开始，再将该磁盘上为卷分配的空间充满。


