1.作业：作业是用户向计算机提交的任务实体，通常体现为用户运行一个程序，一旦作业开始执行，那么期间其无法被打断，即使发现错误也只能等到作业已经执行结束之后再更改，然后再次执行。
进程：进程是计算机为了完成用户任务而设置的执行实体，是资源分配和调度的单位，此处指出，进程不只是指一个程序的代码，还表示该程序当前的活动，是个动态的概念。
线程：线程是进程中的一个实体，是程序执行流的最小单位，是进程内一个相对独立的，可调度的执行单元，是被系统独立调度和分派的基本单位。
在进程提出之前，用的是批处理系统，一批作业在输入运行后，就必须等其完全运行结束后再进行下一次作业，进程的提出使得多程序可以在分时系统中同时运行，提高了CPU的利用率。
线程是个非常小的单位，同时多个线程共享资源，所以相比于单单以进程运行，线程的提出可以减小对CPU的空间使用，从而提高CPU的效率。
2.问题描述：假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考，他们从不交谈。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗意大利面，每两个哲学家之间有一只餐叉。因为用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐叉。
同步：对于某一个哲学家而言，他要拿到两个叉子，就要他的左右两边的叉子都是空闲状态，叉子的状态是同步的，而同时其两边的哲学家就是不能进餐，他们的状态是同步的。
互斥：相邻哲学家对于二者中间的叉子的访问互斥的，二者的进餐状态是互斥的。
死锁：假设每一个哲学家都是先拿自己左边或右边的叉子，那么会出现每个哲学家都手拿着一个叉子，永远等待下一个叉子，这就是死锁。
活锁：假设规定每一个哲学家在拿了一个叉子等待另一个叉子的时间超过五分钟就放下手里的叉子，然后在等待五分钟后进行下一次尝试，那么久不会有死锁问题的出现，但同时如果所有哲学家都同时拿到一个叉子等待下一个，那么又会进入一个没有人能吃到饭的循环，这是活锁。
解法：
服务生解法：引入一个餐厅服务生，哲学家必须经过他的允许才能拿起餐叉。
假设哲学家依次标号为A至E。如果A和C在吃东西，则有四只餐叉在使用中。B坐在A和C之间，所以两只餐叉都无法使用，而D和E之间有一只空余的餐叉。
假设这时D想要吃东西。如果他拿起了第五只餐叉，就有可能发生死锁。相反，如果他征求服务生同意，服务生会让他等待。这样，我们就能保证下次当两把餐叉空余出来时，一定有一位哲学家可以成功的得到一对餐叉，从而避免了死锁。
资源分级解法：为资源（这里是餐叉）分配一个偏序或者分级的关系，并约定所有资源都按照这种顺序获取，按相反顺序释放，而且保证不会有两个无关资源同时被同一项工作所需要。
在哲学家就餐问题中，资源（餐叉）按照某种规则编号为1至5，每一个工作单元（哲学家）总是先拿起左右两边编号较低的餐叉，再拿编号较高的。
用完餐叉后，他总是先放下编号较高的餐叉，再放下编号较低的。在这种情况下，当四位哲学家同时拿起他们手边编号较低的餐叉时，只有编号最高的餐叉留在桌上，从而第五位哲学家就不能使用任何一只餐叉了。
而且，只有一位哲学家能使用最高编号的餐叉，所以他能使用两只餐叉用餐。当他吃完后，他会先放下编号最高的餐叉，再放下编号较低的餐叉，从而让另一位哲学家拿起后边的这只开始吃东西。
Chandy/Misra解法：（1）.对每一对竞争一个资源的哲学家，新拿一个餐叉，给编号较低的哲学家。每只餐叉都是“干净的”或者“脏的”。最初，所有的餐叉都是脏的。
（2）.当一位哲学家要使用资源（也就是要吃东西）时，他必须从与他竞争的邻居那里得到。对每只他当前没有的餐叉，他都发送一个请求。
（3）.当拥有餐叉的哲学家收到请求时，如果餐叉是干净的，那么他继续留着，否则就擦干净并交出餐叉。
（4）.当某个哲学家吃东西后，他的餐叉就变脏了。如果另一个哲学家之前请求过其中的餐叉，那他就擦干净并交出餐叉。
3.磁盘：计算机的外部存储器，其中数据可以反复改写。
分区：分区从实质上说就是对硬盘的一种划分手段，是物理磁盘的一部分，其作用如同一个物理分隔单元。
简单卷：简单卷是物理磁盘的一部分，工作时就好像是物理上的一个独立单元，它与基本磁盘的分区较相似。但是它没有空间的限制以及数量的限制。当简单卷的空间不够用时，您也可以通过扩展卷来扩充其空间，而这丝毫不会影响其中的数据。
跨区卷：由多个物理磁盘上的磁盘空间组成的卷。可以通过向其他动态磁盘扩展来增加跨区卷的容量，只能在动态磁盘上创建跨区卷，跨区卷不能容错也不能被镜像。



