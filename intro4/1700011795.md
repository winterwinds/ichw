概论作业4 Oct/11/2017 1700011795
1、
   作业：计算机操作者（或是作业调度器）交给操作系统的执行单位（任务实体）。是用户在一次算题过程中或一个事务处理中要求计算机系统所做的工作的集合。它是一个比程序更为广泛的面向用户的概念，通常以批的模式运行，在批处理系统中作为基本单位被从外存调入内存。
   进程：计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，是计算机为了完成用户任务实体而设置的执行实体。它拥有自己的地址空间，同时是一个“执行中的程序”，只有操作系统给予其执行所需的资源时，它才能进行活动。具有动态性、并发性、独立性、异步性。
   线程：是程序执行流的最小单元，是进程中的一个相对独立的、可调度的实体（执行单元），是被系统独立调度和分派CPU的基本单位，自己不拥有系统资源，但可以与同属一个进程的其它线程共享进程所拥有的全部资源并与之并发执行，具有就绪、阻塞和运行三种基本状态
   进程的引入解决了多道程序系统中刻画系统内部出现的动态情况的问题，为描述系统内部各道程序的活动规律提供了可能，优化了计算机系统资源的配置，提高了计算机系统资源的利用效率。
   线程的引入解决了早期操作系统以进程为资源拥有单位进行创建、撤销与切换时产生的较大时间消耗，同时解决SMP多个进程并行对资源消耗过大的问题
2、
   哲学家就餐问题：假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗意大利面，每两个哲学家之间有一只餐叉。因为用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐叉。那么，问题就产生了：如何设计一种方法使得哲学家吃意大利面的效率较高？如何避免存在哲学家一直吃不到意大利面的情况？
   服务生解法
   一个简单的解法是引入一个餐厅服务生，哲学家必须经过他的允许才能拿起餐叉。因为服务生知道哪只餐叉正在使用，所以他能够作出判断避免死锁。
   为了演示这种解法，假设哲学家依次标号为A至E。如果A和C在吃东西，则有四只餐叉在使用中。B坐在A和C之间，所以两只餐叉都无法使用，而D和E之间有一只空余的餐叉。假设这时D想要吃东西。如果他拿起了第五只餐叉，就有可能发生死锁。相反，如果他征求服务生同意，服务生会让他等待。这样，我们就能保证下次当两把餐叉空余出来时，一定有一位哲学家可以成功的得到一对餐叉，从而避免了死锁。
   资源分级解法
   另一个简单的解法是为资源（这里是餐叉）分配一个偏序或者分级的关系，并约定所有资源都按照这种顺序获取，按相反顺序释放，而且保证不会有两个无关资源同时被同一项工作所需要。在哲学家就餐问题中，资源（餐叉）按照某种规则编号为1至5，每一个工作单元（哲学家）总是先拿起左右两边编号较低的餐叉，再拿编号较高的。用完餐叉后，他总是先放下编号较高的餐叉，再放下编号较低的。在这种情况下，当四位哲学家同时拿起他们手边编号较低的餐叉时，只有编号最高的餐叉留在桌上，从而第五位哲学家就不能使用任何一只餐叉了。而且，只有一位哲学家能使用最高编号的餐叉，所以他能使用两只餐叉用餐。当他吃完后，他会先放下编号最高的餐叉，再放下编号较低的餐叉，从而让另一位哲学家拿起后边的这只开始吃东西。
尽管资源分级能避免死锁，但这种策略并不总是实用的，特别是当所需资源的列表并不是事先知道的时候。例如，假设一个工作单元拿着资源3和5，并决定需要资源2，则必须先要释放5，之后释放3，才能得到2，之后必须重新按顺序获取3和5。对需要访问大量数据库记录的计算机程序来说，如果需要先释放高编号的记录才能访问新的记录，那么运行效率就不会高，因此这种方法在这里并不实用。
   这种方法经常是实际计算机科学问题中最实用的解法，通过为分级锁指定常量，强制获得锁的顺序，就可以解决这个问题。
   Chandy/Misra解法
   1984年，K. Mani Chandy和J. Misra提出了哲学家就餐问题的另一个解法，允许任意的用户（编号P1, ..., Pn）争用任意数量的资源。与迪科斯彻的解法不同的是，这里编号可以是任意的。
1.对每一对竞争一个资源的哲学家，新拿一个餐叉，给编号较低的哲学家。每只餐叉都是“干净的”或者“脏的”。最初，所有的餐叉都是脏的。
2.当一位哲学家要使用资源（也就是要吃东西）时，他必须从与他竞争的邻居那里得到。对每只他当前没有的餐叉，他都发送一个请求。
3.当拥有餐叉的哲学家收到请求时，如果餐叉是干净的，那么他继续留着，否则就擦干净并交出餐叉。
4.当某个哲学家吃东西后，他的餐叉就变脏了。如果另一个哲学家之前请求过其中的餐叉，那他就擦干净并交出餐叉。
这个解法允许很大的并行性，适用于任意大的问题。
   同步：一般指的是在两个或多个数据库、文件、模块、线程之间用来保持数据内容一致性的机制。
   互斥：计算机系统中，多个并发执行的线程之间由于竞争某些共享资源也可能存在与此类似的相互制约关系，线程之间这种因共享资源而产生的制约关系称为互斥。
   活锁：活锁指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。 
   死锁：指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。
规范定义：集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的。
3、
   磁盘：计算机的外部存储器中也采用了类似磁带的装置，比较常用的一种叫磁盘，将圆形的磁性盘片装在一个方的密封盒子里，这样做的目的是为了防止磁盘表面划伤，导致数据丢失。
   分区：磁盘分区是使用分区编辑器在磁盘上划分几个逻辑部分，盘片一旦划分成数个分区，不同类的目录与文件可以存储进不同的分区。越多分区，也就有更多不同的地方，可以将文件的性质区分得更细，按照更为细分的性质，存储在不同的地方以管理文件；但太多分区就成了麻烦。空间管理、访问许可与目录搜索的方式，依属于安装在分区上的文件系统。当改变大小的能力依属于安装在分区上的文件系统时，需要谨慎地考虑分区的大小。
   简单卷：简单卷是物理磁盘的一部分，但它工作时就好像是物理上的一个独立单元。简单卷是相当于 Windows NT 4.0 及更早版本中的主分区的动态存储。
   跨区卷：如果需要创建卷，但又没有足够的未分配空间分配给单个磁盘上的卷，则可通过将来自多个磁盘的未分配空间的扇区合并到一个跨区卷来创建足够大的卷，这就是跨区卷。跨区卷必须建立在动态磁盘上，是一种和简单卷结构相似的动态卷。跨区卷将来自多个磁盘的未分配空间合并到一个逻辑卷中。